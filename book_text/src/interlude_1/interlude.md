# Interlude: A Shared Workspace Library
> _Key Concepts_
> - Root packages
> - Library crates
> - [Type aliasing](https://doc.rust-lang.org/reference/items/type-aliases.html)

If you followed along with the *Day 1* tutorial, you will know that we defined a function `read_as_lines`. This function will turn any file path into an iterator over the lines of the file.
```rust
fn read_as_lines<T: ToString>(path: T) -> Lines<BufReader<File>> {
    let file = File::open(PathBuf::from(path.to_string()))
        .expect("Cannot open file");

    BufReader::new(file).lines()
}
```
When we defined this file, I hinted that we would be reusing this function often, and I promised we'd add this function to a shared library. Let's do that before we try any more challenges.

To not get lost, let's review what our workspace folder structure looks like right now.
```bash
# aoc/
$ tree
aoc
├───day_1
│   ├───src
│   │   └───"main.rs"
│   └───"cargo.toml"
├───inputs
│   └───"day_1.txt"
├───target              # Autogenerated by rustc
│   └───...
├───"cargo.toml"
├───"cargo.lock"        # Autogenerated by cargo
└───".gitignore"
```
Note that there are two different `cargo.toml` files. The root manifest, `aoc/cargo.toml`, lists our workspace members and dependencies. Right now, this manifest defines a "virtual workspace," meaning it has no top-level package. However, there's nothing stopping us from adding a `package` attribute to our root manifest, thus creating a top-level package (called a _root package_). To me, arbitrarily, it makes sense for a library that's shared by all of our child packages to exist at the root level. Let's modify our root manifest.
```toml
# aoc/cargo.toml
[workspace]
members = ["day_*"]   # Modified! We have enough non-package folders to warrant 
                      # explicit inclusion, rather than exclusion.
exclude = []

# NEW
# Root package contains a library of shared functions.
[package]
name = "aoc"
version = "0.1.0"
edition = "2021"
# ... Any other package metadata: 
#       https://doc.rust-lang.org/cargo/reference/manifest.html
```
With that ready, we can start our library crate. 
```bash
# aoc/
$ mkdir src
$ touch src/lib.rs
```
We should create a test to make sure `cargo` recognizes our new lib crate.
```rust
// aoc/src/lib.rs
#[cfg(test)]
mod lib_tests {

    #[test]
    fn test_compilation() {
        println!("Compilation is a success!");
    }
}
```
Running `cargo test` shows good compilation. The output below is trucated for brevity.
```bash
# aoc/
$ cargo test -- --show-output
running 1 test
test lib_tests::test_compilation ... ok

---- lib_tests::test_compilation stdout ----
Compilation is a success!
```

Great work! We now have a functional root package with a library crate. We can drop in our line-parsing function from earlier, and mark it `pub` for us to use in other packages.

```rust
// aoc/src/lib.rs
use std::{
    fs::File,
    io::{BufRead, BufReader, Lines},
    path::PathBuf,
};

pub fn read_as_lines<T: ToString>(path: T) -> Lines<BufReader<File>> {
    let file = File::open(PathBuf::from(path.to_string()))
        .expect("Cannot open file");

    BufReader::new(file).lines()
}
```
Since this will be a shared library, we should probably include some amount of docscript so others know how to use our function. While we're at it, let's drop the `expect` statement in favor of more appropriate error handling. We can wrap our return object in a `Result` type, with the `Err` variant being the same type that `File::open` passes, i.e. `std::io::Error`.

```rust
// aoc/src/lib.rs
//..

/// Takes in the path to a file, and returns an iterator over the lines of that
/// file. File paths may be absolute or relative to the package, and should be
/// forward-slash delimited (even on Windows systems.) 
pub fn read_as_lines<T: ToString>(path: T) -> Result<Lines<BufReader<File>>, std::io::Error> {
    let file = File::open(PathBuf::from(path.to_string()))?;

    Ok(BufReader::new(file).lines())
}
```

Since we're returning type 

Great job! Your library is ready and you're well equipped to tackle the next challenge.

> **Public Imports?**
> When preparing this 

> **Additional Reading**
> "[Cargo Workspaces](https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html)". _The Rust Programming Lanugage_, ch 143.
> "[Workspaces](https://doc.rust-lang.org/cargo/reference/workspaces.html)". _The Cargo Book_, ch. 3.3.
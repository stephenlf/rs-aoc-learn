# Interlude: A Shared Workspace Library
> _Key Concepts_
> - Root packages
> - Library crates
> - [Type aliasing](https://doc.rust-lang.org/reference/items/type-aliases.html)

If you followed along with the *Day 1* tutorial, you will know that we defined a function `read_as_lines`. This function will turn any file path into an iterator over the lines of the file.
```rust
fn read_as_lines<T: ToString>(path: T) -> Lines<BufReader<File>> {
    let file = File::open(PathBuf::from(path.to_string()))
        .expect("Cannot open file");

    BufReader::new(file).lines()
}
```
When we defined this file, I hinted that we would be reusing this function often, and I promised we'd add this function to a shared library. Let's do that before we try any more challenges.

To not get lost, let's review what our workspace folder structure looks like right now.
```bash
# aoc/
$ tree
aoc
├───day_1
│   ├───src
│   │   └───"main.rs"
│   └───"cargo.toml"
├───inputs
│   └───"day_1.txt"
├───target              # Autogenerated by rustc
│   └───...
├───"cargo.toml"
├───"cargo.lock"        # Autogenerated by cargo
└───".gitignore"
```
Note that there are two different `cargo.toml` files. The root manifest, `aoc/cargo.toml`, lists our workspace members and dependencies. Right now, this manifest defines a "virtual workspace," meaning it has no top-level package. However, there's nothing stopping us from adding a `package` attribute to our root manifest, thus creating a top-level package (called a _root package_). To me, arbitrarily, it makes sense for a library that's shared by all of our child packages to exist at the root level. Let's modify our root manifest.
```toml
# aoc/cargo.toml
[workspace]
members = ["day_*"]   # Modified! We have enough non-package folders to warrant 
                      # explicit inclusion, rather than exclusion.
exclude = []

# NEW
# Root package contains a library of shared functions.
[package]
name = "aoc"
version = "0.1.0"
edition = "2021"
# ... Any other package metadata: 
#       https://doc.rust-lang.org/cargo/reference/manifest.html
```
With that ready, we can start our library crate. 
```bash
# aoc/
$ mkdir src
$ touch src/lib.rs
```
We should create a test to make sure `cargo` recognizes our new lib crate.
```rust
// aoc/src/lib.rs
#[cfg(test)]
mod lib_tests {

    #[test]
    fn test_compilation() {
        println!("Compilation is a success!");
    }
}
```
Running `cargo test` shows good compilation. The output below is trucated for brevity.
```bash
# aoc/
$ cargo test -- --show-output
running 1 test
test lib_tests::test_compilation ... ok

---- lib_tests::test_compilation stdout ----
Compilation is a success!
```

Great work! We now have a functional root package with a library crate. We can drop in our line-parsing function from earlier, and mark it `pub` for us to use in other packages.

```rust
// aoc/src/lib.rs
use std::{
    fs::File,
    io::{BufRead, BufReader, Lines},
    path::PathBuf,
};

pub fn read_as_lines<T: ToString>(path: T) -> Lines<BufReader<File>> {
    let file = File::open(PathBuf::from(path.to_string()))
        .expect("Cannot open file");

    BufReader::new(file).lines()
}
```
Since this will be a shared library, we should probably include some amount of docscript so others know how to use our function. While we're at it, let's drop the `expect` statement in favor of more appropriate error handling. We can wrap our return object in a `Result` type, with the `Err` variant being the same type that `File::open` passes, i.e. `std::io::Error`.

```rust
// aoc/src/lib.rs
//..

/// Takes in the path to a file, and returns an iterator over the lines of that
/// file. File paths may be absolute or relative to the package, and should be
/// forward-slash delimited (even on Windows systems.) 
pub fn read_as_lines<T: ToString>(path: T) -> Result<Lines<BufReader<File>>, std::io::Error> {
    let file = File::open(PathBuf::from(path.to_string()))?;

    Ok(BufReader::new(file).lines())
}
```

## Type aliasing
Since we're returning type `Lines<BufReader<File>>`, we should probably make that type available to our users. They may need to pass the output of our function into some other function, for example. We could make this type available by making our `use` statements `pub`, as in the following example:
```rust
pub use std::{fs::File, io::{BufReader, BufRead, Lines}};
```
However, exporting four different types just to make our one return object accessible is excessive. It increases the likelihood of namespace collisions, not to mention it's just a pain to write out `Lines<BufReader<File>>`. There is a better way.

Rather than export each component of our composite type individually, we can bundle this whole type under a single identifier, or _alias_, using the `type` keyword. Let's add a type alias to `lib.rs` and update our function signature accordingly.

```rust
// aoc/src/lib.rs
pub type LinesIter = std::io::Lines<std::io::BufReader<std::fs::File>>;
// ..
/*                                                       ↓ NEW               */
pub fn read_as_lines<T: ToString>(path: T) -> Result<LinesIter, std::io::Error> {/*...*/}
```

Great job! Your library is ready and you're well equipped to tackle the next challenge.

> **Additional Reading**
> "[Cargo Workspaces](https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html)". _The Rust Programming Lanugage_, ch 143.
> "[Workspaces](https://doc.rust-lang.org/cargo/reference/workspaces.html)". _The Cargo Book_, ch. 3.3.